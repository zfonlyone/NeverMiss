# 任务1：农历支持

## 需求描述
添加农历支持功能，包括农历月份和年份的显示及设置，使用户可以选择使用农历来设置和查看任务日期。

## 技术分析
项目已经引入了 `lunar-javascript` 库，并且在 `services/lunarService.ts` 中有一些初步的农历转换功能实现。需要扩展这些功能，并在 UI 中集成农历日期选择和显示。

## 实施计划

### 1. 完善农历服务
- 增强 `lunarService.ts` 中的函数，确保能够完整支持农历日期转换
- 添加农历月份和年份的格式化函数
- 添加农历节日和传统节日的支持

### 2. 更新任务模型
- 确保 `Task.ts` 模型可以正确标记和处理农历日期
- 更新任务周期计算逻辑，支持农历日期的循环计算

### 3. 创建农历日期选择器组件
- 创建 `LunarDatePicker.tsx` 组件
- 实现农历年、月、日的选择功能
- 支持闰月选择
- 与现有日期选择器保持一致的用户体验

### 4. 更新任务表单
- 在 `TaskFormInline.tsx` 中添加日期类型选择开关
- 根据选择的日期类型显示相应的日期选择器
- 实现公历和农历日期之间的自动转换

### 5. 更新任务详情和列表显示
- 在任务详情页面显示农历日期信息
- 在任务列表中可选择显示农历日期
- 添加农历节日提示

## 相关文件
- `models/Task.ts` - 任务模型
- `services/lunarService.ts` - 农历服务
- `components/TaskFormInline.tsx` - 任务表单
- 待创建: `components/LunarDatePicker.tsx` - 农历日期选择器

## 注意事项
- 农历日期计算比公历更复杂，需要特别注意闰月的处理
- 农历和公历之间的转换要考虑日期范围的有效性
- UI 设计要考虑用户习惯，使农历日期选择直观易用
- 需要考虑国际化支持，针对不同区域用户的需求 

# 任务1：农历支持实施计划

## 概述
任务1的目标是为NeverMiss应用增加农历日期支持功能，使用户可以基于农历创建和跟踪任务。这将使应用更适合需要追踪农历节日和重要日期的用户。

## 现有代码分析

### 现有农历相关功能
- `services/lunarService.ts`中已实现基本的农历日期转换功能
- 使用`lunar-javascript`库实现公农历转换
- Task模型已包含`dateType`字段，可为'solar'或'lunar'
- TaskFormInline组件有初步的农历切换功能

### 主要缺失功能
1. 缺少专门的农历日期选择器组件
2. 任务表单中农历日期选择的UI/UX不完善
3. 循环设置中没有考虑农历特性
4. 缺少农历节日支持和提示

## 实施步骤

### 1. 创建LunarDatePicker组件
创建一个专门的农历日期选择器组件，支持年、月、日和闰月的选择。

```typescript
// components/LunarDatePicker.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, Modal, StyleSheet, FlatList } from 'react-native';
import lunarService from '../services/lunarService';
import { useTheme } from '../contexts/ThemeContext';

interface LunarDatePickerProps {
  value: Date; // 初始日期（公历）
  onChange: (date: Date) => void; // 返回选中的公历日期
  visible: boolean;
  onClose: () => void;
}

export default function LunarDatePicker({ value, onChange, visible, onClose }: LunarDatePickerProps) {
  // 将传入的公历日期转换为农历日期
  const [lunarDate, setLunarDate] = useState(lunarService.solarToLunar(value));
  // 记录用户选择的农历日期
  const [selectedYear, setSelectedYear] = useState(lunarDate.year);
  const [selectedMonth, setSelectedMonth] = useState(lunarDate.month);
  const [selectedDay, setSelectedDay] = useState(lunarDate.day);
  const [isLeapMonth, setIsLeapMonth] = useState(lunarDate.isLeap);
  
  // 状态控制当前显示的选择面板（年/月/日）
  const [currentPanel, setCurrentPanel] = useState<'year' | 'month' | 'day'>('day');
  
  const { colors } = useTheme();

  // 生成年份列表（前后20年）
  const years = Array.from({ length: 41 }, (_, i) => lunarDate.year - 20 + i);
  
  // 生成月份列表（检查是否有闰月）
  const getMonths = () => {
    const months = Array.from({ length: 12 }, (_, i) => i + 1);
    // TODO: 根据实际情况检查特定年份是否有闰月，并添加闰月选项
    return months;
  };
  
  // 生成日期列表（根据年月计算当月天数）
  const getDays = () => {
    // 根据所选年月判断当月天数
    // 暂时固定为30天，实际应根据农历月份特性计算
    return Array.from({ length: 30 }, (_, i) => i + 1);
  };
  
  // 确认选择
  const handleConfirm = () => {
    try {
      // 将选择的农历日期转换为公历
      const solarDate = lunarService.lunarToSolar(selectedYear, selectedMonth, selectedDay, isLeapMonth);
      onChange(solarDate);
      onClose();
    } catch (error) {
      // 处理无效日期错误
      console.error('Invalid lunar date', error);
      // TODO: 显示错误提示
    }
  };
  
  // 渲染年份选择面板
  const renderYearPanel = () => {
    return (
      <FlatList
        data={years}
        numColumns={5}
        keyExtractor={item => `year-${item}`}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.itemButton,
              selectedYear === item && [styles.selectedItem, { backgroundColor: colors.primary }]
            ]}
            onPress={() => setSelectedYear(item)}
          >
            <Text style={selectedYear === item ? styles.selectedItemText : { color: colors.text }}>
              {item}
            </Text>
          </TouchableOpacity>
        )}
      />
    );
  };
  
  // 渲染月份选择面板
  const renderMonthPanel = () => {
    return (
      <FlatList
        data={getMonths()}
        numColumns={4}
        keyExtractor={item => `month-${item}`}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.itemButton,
              selectedMonth === item && !isLeapMonth && [styles.selectedItem, { backgroundColor: colors.primary }]
            ]}
            onPress={() => {
              setSelectedMonth(item);
              setIsLeapMonth(false);
            }}
          >
            <Text style={selectedMonth === item && !isLeapMonth ? styles.selectedItemText : { color: colors.text }}>
              {lunarService.getLunarMonthName(item)}
            </Text>
          </TouchableOpacity>
        )}
      />
    );
  };
  
  // 渲染日期选择面板
  const renderDayPanel = () => {
    return (
      <FlatList
        data={getDays()}
        numColumns={7}
        keyExtractor={item => `day-${item}`}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.itemButton,
              selectedDay === item && [styles.selectedItem, { backgroundColor: colors.primary }]
            ]}
            onPress={() => setSelectedDay(item)}
          >
            <Text style={selectedDay === item ? styles.selectedItemText : { color: colors.text }}>
              {lunarService.getLunarDayName(item)}
            </Text>
          </TouchableOpacity>
        )}
      />
    );
  };
  
  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.modalContainer}>
        <View style={[styles.pickerContainer, { backgroundColor: colors.background }]}>
          <View style={styles.header}>
            <TouchableOpacity onPress={onClose}>
              <Text style={{ color: colors.text }}>取消</Text>
            </TouchableOpacity>
            <Text style={[styles.title, { color: colors.text }]}>选择农历日期</Text>
            <TouchableOpacity onPress={handleConfirm}>
              <Text style={{ color: colors.primary }}>确定</Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.tabsContainer}>
            <TouchableOpacity 
              style={[styles.tab, currentPanel === 'year' && styles.activeTab]} 
              onPress={() => setCurrentPanel('year')}
            >
              <Text style={{ color: currentPanel === 'year' ? colors.primary : colors.text }}>
                {selectedYear}年
              </Text>
            </TouchableOpacity>
            <TouchableOpacity 
              style={[styles.tab, currentPanel === 'month' && styles.activeTab]} 
              onPress={() => setCurrentPanel('month')}
            >
              <Text style={{ color: currentPanel === 'month' ? colors.primary : colors.text }}>
                {isLeapMonth ? '闰' : ''}{lunarService.getLunarMonthName(selectedMonth)}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity 
              style={[styles.tab, currentPanel === 'day' && styles.activeTab]} 
              onPress={() => setCurrentPanel('day')}
            >
              <Text style={{ color: currentPanel === 'day' ? colors.primary : colors.text }}>
                {lunarService.getLunarDayName(selectedDay)}
              </Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.panelContainer}>
            {currentPanel === 'year' && renderYearPanel()}
            {currentPanel === 'month' && renderMonthPanel()}
            {currentPanel === 'day' && renderDayPanel()}
          </View>
          
          <Text style={[styles.previewText, { color: colors.subText }]}>
            {`${selectedYear}年${isLeapMonth ? '闰' : ''}${lunarService.getLunarMonthName(selectedMonth)}${lunarService.getLunarDayName(selectedDay)}`}
            {' '} - {' '}
            {new Date(lunarService.lunarToSolar(selectedYear, selectedMonth, selectedDay, isLeapMonth)).toLocaleDateString()}
          </Text>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  pickerContainer: {
    borderTopLeftRadius: 10,
    borderTopRightRadius: 10,
    padding: 16,
    maxHeight: '80%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  tabsContainer: {
    flexDirection: 'row',
    marginVertical: 10,
  },
  tab: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginRight: 8,
    borderRadius: 4,
  },
  activeTab: {
    backgroundColor: 'rgba(0,0,0,0.05)',
  },
  panelContainer: {
    flex: 1,
    minHeight: 220,
  },
  itemButton: {
    padding: 10,
    margin: 4,
    borderRadius: 4,
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedItem: {
    backgroundColor: '#007AFF',
  },
  selectedItemText: {
    color: 'white',
  },
  previewText: {
    textAlign: 'center',
    marginTop: 10,
    fontSize: 14,
  },
});
```

### 2. 增强 lunarService.ts 服务
为现有的lunar服务添加新功能，支持更完善的农历日期操作。

```typescript
// 添加到 services/lunarService.ts

/**
 * 获取特定年份的闰月（如果有）
 * @param year 农历年份
 * @returns 闰月月份，如果没有返回0
 */
export function getLeapMonth(year: number): number {
  return Lunar.fromYmd(year, 1, 1).getLeapMonth();
}

/**
 * 获取农历月份的天数
 * @param year 农历年
 * @param month 农历月
 * @param isLeap 是否闰月
 * @returns 该月天数
 */
export function getLunarMonthDays(year: number, month: number, isLeap: boolean = false): number {
  const lunar = Lunar.fromYmd(year, month, 1);
  // TODO: 实现获取月份天数的逻辑
  return isLeap ? lunar.getLeapMonthDays(year, month) : lunar.getMonthDays(year, month);
}

/**
 * 检查指定日期是否为农历节日
 * @param month 农历月
 * @param day 农历日
 * @returns 节日名称，如果不是节日则返回空字符串
 */
export function getLunarFestival(month: number, day: number): string {
  // 主要农历节日列表
  const festivals: {[key: string]: string} = {
    '1-1': '春节',
    '1-15': '元宵节',
    '5-5': '端午节',
    '7-7': '七夕',
    '8-15': '中秋节',
    '9-9': '重阳节',
    '12-30': '除夕' // 注意：除夕实际上是农历最后一天，可能是29日
  };
  
  const key = `${month}-${day}`;
  return festivals[key] || '';
}
```

### 3. 更新TaskFormInline组件
增强现有的TaskFormInline组件，添加农历日期选择功能。

```typescript
// 修改 components/TaskFormInline.tsx

// 添加导入
import LunarDatePicker from './LunarDatePicker';

// 添加组件状态
const [showLunarPicker, setShowLunarPicker] = useState(false);
const [currentEditingDateField, setCurrentEditingDateField] = useState<'startDate' | 'dueDate'>('startDate');

// 修改formatDisplayDate函数，显示更精确的农历日期
const formatDisplayDate = (dateString: string) => {
  if (useLunar) {
    const date = new Date(dateString);
    const lunarDate = lunarService.solarToLunar(date);
    return `${lunarDate.year}年${lunarDate.isLeap ? '闰' : ''}${lunarService.getLunarMonthName(lunarDate.month)}${lunarService.getLunarDayName(lunarDate.day)}`;
  }
  return format(new Date(dateString), 'yyyy-MM-dd HH:mm');
};

// 添加农历日期选择器处理函数
const handleLunarDateSelected = (date: Date) => {
  setFormData({
    ...formData,
    [currentEditingDateField]: date.toISOString()
  });
};

// 修改日期选择部分UI
// 替换 "开始日期" 部分的 TouchableOpacity 的 onPress 事件:
onPress={() => {
  if (useLunar) {
    setCurrentEditingDateField('startDate');
    setShowLunarPicker(true);
  } else {
    setPickerMode('date');
    setShowStartPicker(true);
  }
}}

// 添加农历日期选择器组件
{showLunarPicker && (
  <LunarDatePicker
    value={new Date(formData[currentEditingDateField])}
    onChange={handleLunarDateSelected}
    visible={showLunarPicker}
    onClose={() => setShowLunarPicker(false)}
  />
)}
```

### 4. 更新RecurrenceSettings组件
修改RecurrenceSettings组件以支持农历循环设置。

```typescript
// 修改 components/RecurrenceSettings.tsx

// 添加状态和属性
const [useLunarForRecurrence, setUseLunarForRecurrence] = useState(
  props.initialValues?.dateType === 'lunar' || false
);

// 在组件中添加农历切换开关
<View style={styles.dateTypeContainer}>
  <Text style={[styles.label, { color: colors.text }]}>日期类型</Text>
  <View style={styles.dateTypeSwitch}>
    <Text style={[styles.dateTypeText, { color: !useLunarForRecurrence ? colors.primary : colors.text }]}>公历</Text>
    <Switch
      value={useLunarForRecurrence}
      onValueChange={(value) => {
        setUseLunarForRecurrence(value);
        if (props.onDateTypeChange) {
          props.onDateTypeChange(value ? 'lunar' : 'solar');
        }
      }}
    />
    <Text style={[styles.dateTypeText, { color: useLunarForRecurrence ? colors.primary : colors.text }]}>农历</Text>
  </View>
</View>

// 在循环预览文本中添加农历支持
const getRecurrencePreviewText = () => {
  // 获取循环类型的描述文本
  let previewText = '';
  const dateTypeText = useLunarForRecurrence ? '（农历）' : '';
  
  switch (recurrenceType) {
    case 'daily':
      previewText = `每${recurrenceValue}天${dateTypeText}`;
      break;
    case 'weekly':
      previewText = `每${recurrenceValue}周${dateTypeText}`;
      break;
    case 'monthly':
      previewText = `每${recurrenceValue}个月${dateTypeText}`;
      break;
    case 'yearly':
      previewText = `每${recurrenceValue}年${dateTypeText}`;
      break;
    case 'custom':
      if (recurrenceValue <= 0) {
        previewText = '无循环';
      } else {
        const unit = recurrenceUnit === 'days' ? '天' :
                    recurrenceUnit === 'weeks' ? '周' :
                    recurrenceUnit === 'months' ? '个月' : '年';
        previewText = `每${recurrenceValue}${unit}${dateTypeText}`;
      }
      break;
    default:
      previewText = '无循环';
  }
  
  return previewText;
};
```

### 5. 更新任务周期处理逻辑
修改任务周期生成逻辑，支持农历日期计算。

```typescript
// 修改 services/taskService.ts 中的相关函数

/**
 * 计算下一个周期的到期日期
 * @param task 任务
 * @param dateType 日期类型（公历/农历）
 * @param lastDueDate 上一个周期的到期日期
 * @returns 下一个周期的到期日期
 */
export function calculateNextDueDate(task: Task, lastDueDate: string): string {
  const lastDueDateObj = new Date(lastDueDate);
  let nextDueDate: Date;
  
  // 判断是否使用农历
  if (task.dateType === 'lunar') {
    // 将上一个到期日转换为农历日期
    const lastLunarDate = lunarService.solarToLunar(lastDueDateObj);
    
    // 根据循环类型计算下一个农历日期
    let nextLunarYear = lastLunarDate.year;
    let nextLunarMonth = lastLunarDate.month;
    let nextLunarDay = lastLunarDate.day;
    
    switch (task.recurrencePattern.type) {
      case 'daily':
        // 不能简单加天数，需要在农历日期上操作
        // 这里用简化方法：转换为公历加天数再转回农历
        nextDueDate = new Date(lastDueDateObj.getTime() + task.recurrencePattern.value * 24 * 60 * 60 * 1000);
        break;
        
      case 'weekly':
        // 同样用简化方法
        nextDueDate = new Date(lastDueDateObj.getTime() + task.recurrencePattern.value * 7 * 24 * 60 * 60 * 1000);
        break;
        
      case 'monthly':
        // 加农历月份
        nextLunarMonth += task.recurrencePattern.value;
        while (nextLunarMonth > 12) {
          nextLunarMonth -= 12;
          nextLunarYear += 1;
        }
        
        // 检查该月天数上限
        const monthDays = lunarService.getLunarMonthDays(nextLunarYear, nextLunarMonth, lastLunarDate.isLeap);
        if (nextLunarDay > monthDays) {
          nextLunarDay = monthDays;
        }
        
        // 转换回公历
        nextDueDate = lunarService.lunarToSolar(nextLunarYear, nextLunarMonth, nextLunarDay, lastLunarDate.isLeap);
        break;
        
      case 'yearly':
        // 加农历年份
        nextLunarYear += task.recurrencePattern.value;
        
        // 检查该月天数上限（闰年处理）
        const yearMonthDays = lunarService.getLunarMonthDays(nextLunarYear, nextLunarMonth, lastLunarDate.isLeap);
        if (nextLunarDay > yearMonthDays) {
          nextLunarDay = yearMonthDays;
        }
        
        // 转换回公历
        nextDueDate = lunarService.lunarToSolar(nextLunarYear, nextLunarMonth, nextLunarDay, lastLunarDate.isLeap);
        break;
        
      default:
        // 默认不循环，直接返回原日期
        return lastDueDate;
    }
  } else {
    // 公历计算逻辑（保持原有）
    switch (task.recurrencePattern.type) {
      case 'daily':
        nextDueDate = addDays(lastDueDateObj, task.recurrencePattern.value);
        break;
      case 'weekly':
        nextDueDate = addDays(lastDueDateObj, task.recurrencePattern.value * 7);
        break;
      case 'monthly':
        nextDueDate = addMonths(lastDueDateObj, task.recurrencePattern.value);
        break;
      case 'yearly':
        nextDueDate = addYears(lastDueDateObj, task.recurrencePattern.value);
        break;
      default:
        return lastDueDate;
    }
  }
  
  return nextDueDate.toISOString();
}
```

### 6. 添加农历相关UI元素
在任务列表和任务详情页面添加农历信息显示。

```typescript
// 修改 components/TaskList.tsx 中的任务项目渲染

// 添加农历提示信息
const renderTaskItem = ({ item }: { item: Task }) => {
  // 现有代码...
  
  // 添加农历标识和信息
  const showLunarInfo = item.dateType === 'lunar';
  let lunarInfo = '';
  
  if (showLunarInfo && item.currentCycle) {
    const dueDate = new Date(item.currentCycle.dueDate);
    const lunarDate = lunarService.solarToLunar(dueDate);
    lunarInfo = `${lunarDate.year}年${lunarDate.isLeap ? '闰' : ''}${lunarService.getLunarMonthName(lunarDate.month)}${lunarService.getLunarDayName(lunarDate.day)}`;
    
    // 检查是否为农历节日
    const festival = lunarService.getLunarFestival(lunarDate.month, lunarDate.day);
    if (festival) {
      lunarInfo += ` (${festival})`;
    }
  }
  
  // 渲染UI时添加农历信息
  return (
    <TouchableOpacity 
      style={styles.taskItem} 
      onPress={() => onTaskPress(item)}
    >
      {/* 现有代码... */}
      
      {showLunarInfo && (
        <Text style={styles.lunarInfo}>
          <Ionicons name="moon-outline" size={14} color="#666" /> {lunarInfo}
        </Text>
      )}
      
      {/* 其他现有代码... */}
    </TouchableOpacity>
  );
};
```

## 测试计划

1. **基本功能测试**
   - 测试创建农历任务
   - 确认农历日期显示正确
   - 验证农历任务的到期通知

2. **日期转换测试**
   - 在不同日期类型间切换，验证日期转换正确
   - 测试闰月处理
   - 测试农历特殊日期（如除夕）

3. **循环设置测试**
   - 测试农历日、周、月、年循环
   - 测试跨闰月的循环
   - 验证循环预览文本

4. **兼容性测试**
   - 确保现有公历任务不受影响
   - 测试导入/导出含农历任务的数据

## 实施进度计划

1. 开发LunarDatePicker组件 (2天)
2. 增强lunarService服务 (1天)
3. 更新TaskFormInline组件 (1天)
4. 更新RecurrenceSettings组件 (1天)
5. 更新任务周期处理逻辑 (2天)
6. 添加农历相关UI元素 (1天)
7. 测试和调试 (2天)

总计: 10天 